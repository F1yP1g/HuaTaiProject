package com.lu.loadbalance;
import com.lu.address.*;
import java.util.LinkedList;  
import java.util.List;  
import java.util.SortedMap;  
import java.util.TreeMap;  

public class ConsistentHashBalance {

    //真实结点列表
    private static List<String> realNodes = new LinkedList<String>();  

    //虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称  
    private static SortedMap<Integer, String> virtualNodes = new TreeMap<Integer, String>();  

    //虚拟节点的数目,一个真实结点对应5个虚拟节点  
    private static final int VIRTUAL_NODES = 5;  

    static{  
        //先把原始的服务器添加到真实结点列表中  
        for(int i=0; i<ServerAddresses.servers.length; i++)  
            realNodes.add(ServerAddresses.servers[i]);  

        //再添加虚拟节点
        for (String str : realNodes){  
            for(int i=0; i<VIRTUAL_NODES; i++){  
                String virtualNodeName = str + "&&VN" + String.valueOf(i);  
                int hash = getHash(virtualNodeName);  
                virtualNodes.put(hash, virtualNodeName);  
            }  
        }  
        System.out.println();  
    }  

    //使用FNV1_32_HASH算法
    private static int getHash(String str){  
        final int p = 16777619;  
        int hash = (int)2166136261L;  
        for (int i = 0; i < str.length(); i++)  
            hash = (hash ^ str.charAt(i)) * p;  
        hash += hash << 13;  
        hash ^= hash >> 7;  
        hash += hash << 3;  
        hash ^= hash >> 17;  
        hash += hash << 5;  

        // 如果算出来的值为负数则取其绝对值  
        if (hash < 0)  
            hash = Math.abs(hash);  
        return hash;  
    }  

    //得到应当路由到的结点  
    public  static String getConsistentHashServer(String key){  
       //得到该key的hash值  
        int hash = getHash(key);  
        // 得到大于该Hash值的所有Map  
        SortedMap<Integer, String> subMap = virtualNodes.tailMap(hash);  
        String virtualNode;  
        if(subMap.isEmpty()){  
           //如果没有比该key的hash值大的，则从第一个node开始  
           Integer i = virtualNodes.firstKey();  
           //返回对应的服务器  
           virtualNode = virtualNodes.get(i);  
        }else{  
           //第一个Key就是顺时针过去离node最近的那个结点  
           Integer i = subMap.firstKey();  
           //返回对应的服务器  
           virtualNode = subMap.get(i);  
        }  
        //virtualNode虚拟节点名称截取
        if(virtualNode != null){  
            return virtualNode.substring(0, virtualNode.indexOf("&&"));  
        }  
        return null;  
    } 
}